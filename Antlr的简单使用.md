# Antlr的简单使用

## 解析过程

我们将解析分为两个阶段，对应我们的大脑读取文字时的过程。当我们读到一个句子时，在第一阶段，大脑会下意识地将字符组成单词，然后像查词典一样识别出它们的意思。在第二阶段，大脑会根据已识别的单词去识别句子的结构。第一阶段的过程叫词法分析（lexical analysis），对应的分析程序叫做lexer，负责将符号（token）分组成符号类（token class or token type）。而第二阶段就是真正的parser，默认ANTLR会构建出一棵分析树（parse tree）或叫语法树（syntax tree）。如下图，就是简单的赋值表达式的解析过程：

![](/home/g/图片/20150430212251393.png)

语法树的叶子是输入token，而上级结点时包含其孩子结点的词组名（phase），线性的句子其实是语法树的序列化。最终生成语法树的好处是：

1） 树形结构易于遍历和处理，并且易被程序员理解，方便了应用代码做进一步处理。

2） 多种解释或翻译的应用代码都可以重用一个解析器。但ANTLR也支持像传统解析器生成器那样，将应用处理代码嵌入到语法中。

3） 对于因为计算依赖而需要多趟处理的翻译器来说，语法树非常有用！我们不用多次调用解析器去解析，只需高效地遍历语法树多次。

## 深入ANTLR

ANTLR生成的解析器叫做递归下降解析器（recursive-descent parser），属于自顶向下解析器（top-down parser）的一种。顾名思义，递归下降指的就是解析过程是从语法树的根开始向叶子（token）递归，比较酷的是代码的调用图能与树结点对应上。还是以前面的赋值表达式解析为例，其递归下降解析器的代码大概是下面这个样子：

![](/home/g/图片/20150430212423197.png)

Assign很简单，直接顺序读取输入字符，不用做任何选择。相比之下，根结点Stat要复杂一些，因为它有多种选择。解析时，要**向前看（lookahead）**一些字符才能确认走哪个分支代码，有时甚至要读取完所有输入才能预测出，而ANTLR默默为我们处理了一切！

简单的Antlr语法
--------------------- 

在Antlr中字符串是用单引号引起来的，如果需要小时单引号，需要加上一个反斜杠表示转义（和C语言及Java用法一样）就像："\"

定义一个产生式的形式如下

`产生式左部 ： 产生式右部 ：`

“|”表示或，表示两边的符号出现任意一个都会匹配。比如“a|b”表示出现a或者出现b都会匹配

“()+”表示括号内部的符号可以出现一次或者多次，例如

**巴科斯范式扩展符号 EBNF** 

() : 产生式组合 

?  : 产生式出现0或1次 

*: 0或多次 

+: 1或多次 

.   : 任意一个字符 

~  : 不出现后面的字符 

..  : 字符范围





如果文法文件是错的就生成不了抽象语法树，如果生成了抽象语法树但结果错了就要改动主函数